// scripts/build-content.mjs
import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import fg from 'fast-glob'
import matter from 'gray-matter'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

// Adjust these if your structure differs
const BLOG_DIR = path.join(projectRoot, 'public', 'blog')
const OUTPUT_JS = path.join(projectRoot, 'src', 'utils', 'expandedBlogPosts.js')
const SITEMAP_XML = path.join(projectRoot, 'public', 'sitemap.xml')

// For sitemap (override via env if you want)
const SITE_URL = process.env.SITE_URL || 'https://uptrademedia.com'

// Try to infer a hero image if none is provided
const IMAGE_CANDIDATES = ['.jpg', '.jpeg', '.png', '.webp', '.avif']

function toSlug(s) {
  return String(s || '')
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .trim()
    .replace(/\s+/g, '-')
}

function words(str) {
  return (str || '')
    .replace(/```[\s\S]*?```/g, '') // strip code fences
    .replace(/<[^>]*>/g, '')        // strip html
    .split(/\s+/)
    .filter(Boolean)
}

function estimateReadTime(md) {
  const w = words(md).length
  const minutes = Math.max(1, Math.round(w / 220))
  return `${minutes} min read`
}

async function findFallbackImage(category, slug) {
  // Look for public/blog/<category>/<slug>.(jpg|png|webp|…)
  const dir = path.join(BLOG_DIR, category)
  for (const ext of IMAGE_CANDIDATES) {
    const p = path.join(dir, `${slug}${ext}`)
    try {
      await fs.access(p)
      // Return the PUBLIC path users can request
      return `/blog/${category}/${slug}${ext}`
    } catch (_) {}
  }
  return null
}

function normalizeTags(tags) {
  if (!tags) return []
  if (Array.isArray(tags)) return tags
  if (typeof tags === 'string') {
    return tags
      .split(',')
      .map((t) => t.trim())
      .filter(Boolean)
  }
  return []
}

function excerptFrom(md) {
  const text = words(md).join(' ')
  const first = text.split(/\s+/).slice(0, 40).join(' ')
  return first ? `${first}…` : ''
}

async function loadPosts() {
  // Glob all markdown files under public/blog/**.md
  const entries = await fg('**/*.md', { cwd: BLOG_DIR, dot: false })
  const posts = []

  for (const rel of entries) {
    const abs = path.join(BLOG_DIR, rel)
    const raw = await fs.readFile(abs, 'utf8')

    // Parse front-matter
    const { data: fm, content } = matter(raw)

    // category from path folder: e.g. marketing/slug.md
    const parts = rel.split(path.sep)
    const category = (fm.category || parts[0] || '').toLowerCase()

    // slug from filename (or front-matter override)
    const base = path.basename(rel, path.extname(rel))
    const slug = fm.slug ? toSlug(fm.slug) : toSlug(base)

    // date (require it; fallback to file mtime if missing)
    let dateStr = fm.date
    if (!dateStr) {
      const stat = await fs.stat(abs)
      dateStr = new Date(stat.mtime).toISOString().slice(0, 10)
    }

    // image: use fm.image or infer
    let image = fm.image || null
    if (!image) {
      image = await findFallbackImage(category, slug)
    }

    const title = fm.title || slug.replace(/-/g, ' ')
    const tags = normalizeTags(fm.tags)
    const excerpt = fm.excerpt || excerptFrom(content)
    const readTime = fm.readTime || estimateReadTime(content)
    const featured = Boolean(fm.featured)
    const author = fm.author || 'Uptrade Media'
    const id = fm.id || slug

    // Compose final post object
    posts.push({
      id,
      title,
      excerpt,
      category,
      date: dateStr,
      readTime,
      tags,
      featured,
      slug,
      image,
      author,
      // Optionals if you want:
      publishDate: fm.publishDate || dateStr,
      modifiedDate: fm.modifiedDate || fm.publishDate || dateStr,
    })
  }

  // Sort newest first
  posts.sort((a, b) => new Date(b.date) - new Date(a.date))
  return posts
}

function toJSModule(posts) {
  const json = JSON.stringify(posts, null, 2)
  return `// AUTO-GENERATED FILE. Do not edit by hand.
// Generated by scripts/build-content.mjs
export const expandedBlogPosts = ${json};
`
}

async function writeExpanded(posts) {
  const code = toJSModule(posts)
  await fs.mkdir(path.dirname(OUTPUT_JS), { recursive: true })
  await fs.writeFile(OUTPUT_JS, code, 'utf8')
  console.log(`✓ wrote ${path.relative(projectRoot, OUTPUT_JS)} (${posts.length} posts)`)
}

function xmlEscape(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}

async function writeSitemap(posts) {
  const urls = [
    { loc: `${SITE_URL}/`, changefreq: 'weekly', priority: '1.0' },
    { loc: `${SITE_URL}/insights`, changefreq: 'daily', priority: '0.9' },
    ...posts.map((p) => ({
      loc: `${SITE_URL}/insights/${p.slug}`,
      lastmod: new Date(p.modifiedDate || p.date).toISOString(),
      changefreq: 'monthly',
      priority: '0.7',
    })),
  ]

  const body = urls
    .map((u) => {
      const parts = [
        `<loc>${xmlEscape(u.loc)}</loc>`,
        u.lastmod ? `<lastmod>${u.lastmod}</lastmod>` : '',
        u.changefreq ? `<changefreq>${u.changefreq}</changefreq>` : '',
        u.priority ? `<priority>${u.priority}</priority>` : '',
      ].filter(Boolean)
      return `  <url>\n    ${parts.join('\n    ')}\n  </url>`
    })
    .join('\n')

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<!-- AUTO-GENERATED by scripts/build-content.mjs -->
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
${body}
</urlset>
`
  await fs.writeFile(SITEMAP_XML, xml, 'utf8')
  console.log(`✓ wrote ${path.relative(projectRoot, SITEMAP_XML)}`)
}

async function main() {
  try {
    // If blog dir doesn't exist, skip gracefully
    try {
      await fs.access(BLOG_DIR)
    } catch {
      console.warn(`⚠ Blog directory not found: ${path.relative(projectRoot, BLOG_DIR)}. Skipping.`)
      return
    }

    const posts = await loadPosts()
    await writeExpanded(posts)
    await writeSitemap(posts)
  } catch (err) {
    console.error('build-content error:', err)
    process.exitCode = 1
  }
}

await main()
